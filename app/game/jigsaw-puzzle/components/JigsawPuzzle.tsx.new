'use client'

import React, { useState, useEffect, useCallback, useMemo } from 'react'
import { Card } from '@/components/ui/card'
import { useJigsawStats } from '../hooks/useJigsawStats'
import { usePuzzleActions } from '../hooks/usePuzzleActions'
import { usePuzzleLayout } from '../hooks/usePuzzleLayout'
import { usePuzzleInteraction } from '../hooks/usePuzzleInteraction'
import { loadImage, getBackgroundSize, getBackgroundPosition } from '../utils/imageUtils'
import { initializePuzzlePieces, initializePuzzleSlots, isGameComplete, type PuzzlePiece, type PuzzleSlot } from '../utils/puzzleUtils'
import {
  GameInfoCard,
  FloatingReference,
  PuzzleBoard,
  GameStats,
  CompletionMessage,
  PieceSelectionArea,
} from './puzzle'

interface JigsawPuzzleProps {
  imageUrl: string
  size: number
  onComplete: () => void
}

export default function JigsawPuzzle({ imageUrl, size, onComplete }: JigsawPuzzleProps) {
  const [pieces, setPieces] = useState<PuzzlePiece[]>([])
  const [slots, setSlots] = useState<PuzzleSlot[]>([])
  const [startTime, setStartTime] = useState(new Date())
  const [isComplete, setIsComplete] = useState(false)
  const [imageLoaded, setImageLoaded] = useState(false)
  const [draggedPiece, setDraggedPiece] = useState<number | null>(null)
  const [showFloatingReference, setShowFloatingReference] = useState(false)
  const [selectedPlacedPiece, setSelectedPlacedPiece] = useState<number | null>(null)
  const [wronglyPlacedPieces, setWronglyPlacedPieces] = useState<Set<number>>(new Set())
  const [lastWronglyPlacedPiece, setLastWronglyPlacedPiece] = useState<number | null>(null)
  const [currentTab, setCurrentTab] = useState('0')
  const [showPieceNumbers, setShowPieceNumbers] = useState(false)
  const [showDebugInfo, setShowDebugInfo] = useState(true)
  const [tabsNeedScrolling, setTabsNeedScrolling] = useState(false)
  const [piecePreviewVisible, setPiecePreviewVisible] = useState(false)
  const [piecePreviewPiece, setPiecePreviewPiece] = useState<PuzzlePiece | null>(null)
  const [piecePreviewPosition, setPiecePreviewPosition] = useState({ x: 0, y: 0 })
  const [availableHeight, setAvailableHeight] = useState(400)
  const [imageDimensions, setImageDimensions] = useState({ width: 0, height: 0 })
  const { stats, updateStats } = useJigsawStats(size)

  const puzzleSize = Math.min(400, Math.max(300, 60 * size))
  const pieceSize = puzzleSize / size

  // 初始化拼图
  const initializePuzzle = useCallback(() => {
    const newPieces = initializePuzzlePieces(size, imageUrl, puzzleSize)
    const newSlots = initializePuzzleSlots(size)

    setPieces(newPieces)
    setSlots(newSlots)
    setStartTime(new Date())
    setIsComplete(false)
    setWronglyPlacedPieces(new Set())
    setLastWronglyPlacedPiece(null)
  }, [imageUrl, size, puzzleSize])

  // 图片加载完成后初始化拼图
  useEffect(() => {
    if (imageUrl) {
      loadImage(imageUrl)
        .then(dimensions => {
          setImageDimensions(dimensions)
          setImageLoaded(true)
          initializePuzzle()
        })
        .catch(() => {
          console.error('图片加载失败')
          setImageLoaded(false)
        })
    }
  }, [imageUrl, initializePuzzle])

  // 检查游戏完成状态
  const checkGameCompletion = useCallback(() => {
    if (isGameComplete(pieces, slots)) {
      setIsComplete(true)
      const completionTime = Math.floor((new Date().getTime() - startTime.getTime()) / 1000)
      updateStats(completionTime, pieces.length)
      onComplete()
    }
  }, [pieces, slots, startTime, updateStats, onComplete])

  // 使用拼图操作 hooks
  const { placePieceInSlot, swapPieces, replacePieceWithUnplaced } = usePuzzleActions({
    pieces,
    slots,
    setPieces,
    setSlots,
    wronglyPlacedPieces,
    setWronglyPlacedPieces,
    lastWronglyPlacedPiece,
    setLastWronglyPlacedPiece,
    onComplete: checkGameCompletion,
  })

  // 使用拼图交互 hooks
  const {
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    handleDrop,
    handlePieceClick,
    handlePlacedPieceClick,
    handleSlotClick,
    cancelSelection,
  } = usePuzzleInteraction({
    pieces,
    slots,
    draggedPiece,
    setDraggedPiece,
    selectedPlacedPiece,
    setSelectedPlacedPiece,
    lastWronglyPlacedPiece,
    setWronglyPlacedPieces,
    setLastWronglyPlacedPiece,
    setPieces,
    setSlots,
    placePieceInSlot,
    swapPieces,
    replacePieceWithUnplaced,
    checkGameCompletion,
  })

  // 键盘事件监听
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        cancelSelection()
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => {
      document.removeEventListener('keydown', handleKeyDown)
    }
  }, [cancelSelection])

  // 计算可用高度
  useEffect(() => {
    const calculateAvailableHeight = () => {
      const windowHeight = window.innerHeight
      const appBarHeight = 64
      const gameInfoCardHeight = 140
      const puzzleAreaHeight = puzzleSize + 60
      const statisticsCardHeight = stats.gamesCompleted > 0 ? 120 : 0
      const verticalSpacing = 80

      const usedHeight =
        appBarHeight +
        gameInfoCardHeight +
        puzzleAreaHeight +
        statisticsCardHeight +
        verticalSpacing

      const available = Math.max(300, Math.min(windowHeight * 0.6, windowHeight - usedHeight))
      setAvailableHeight(available)
    }

    calculateAvailableHeight()
    window.addEventListener('resize', calculateAvailableHeight)

    return () => {
      window.removeEventListener('resize', calculateAvailableHeight)
    }
  }, [puzzleSize, stats.gamesCompleted])

  // 使用布局计算 hook
  const layout = usePuzzleLayout({
    pieces,
    size,
    puzzleSize,
    availableHeight,
    showDebugInfo,
  })

  // 处理拼图块预览事件
  const handlePiecePreviewStart = useCallback(
    (e: React.MouseEvent | React.TouchEvent, piece: PuzzlePiece) => {
      e.preventDefault()
      e.stopPropagation()

      const rect = (e.currentTarget as HTMLElement).getBoundingClientRect()
      setPiecePreviewPosition({
        x: rect.left + rect.width / 2,
        y: rect.top,
      })

      setPiecePreviewPiece(piece)
      setPiecePreviewVisible(true)
    },
    []
  )

  const handlePiecePreviewEnd = useCallback(() => {
    setPiecePreviewVisible(false)
    setPiecePreviewPiece(null)
  }, [])

  // 重新开始游戏
  const resetGame = useCallback(() => {
    initializePuzzle()
    setCurrentTab('0')
    setDraggedPiece(null)
    setSelectedPlacedPiece(null)
    setWronglyPlacedPieces(new Set())
    setLastWronglyPlacedPiece(null)
  }, [initializePuzzle, setDraggedPiece, setSelectedPlacedPiece])

  // 背景尺寸和位置计算函数
  const getBackgroundSizeMemo = useCallback(
    (containerSize: number) => {
      return getBackgroundSize(containerSize, size, imageDimensions)
    },
    [size, imageDimensions]
  )

  const getBackgroundPositionMemo = useCallback(
    (row: number, col: number, containerSize: number) => {
      return getBackgroundPosition(row, col, containerSize, size, imageDimensions)
    },
    [size, imageDimensions]
  )

  if (!imageLoaded) {
    return (
      <Card className="p-8 text-center">
        <div className="animate-pulse">
          <div className="mx-auto mb-4 h-64 w-64 rounded-lg bg-gray-200"></div>
          <p>加载图片中...</p>
        </div>
      </Card>
    )
  }

  return (
    <div className="flex flex-col items-center space-y-4">
      {/* 游戏信息和操作提示 */}
      <GameInfoCard
        pieces={pieces}
        startTime={startTime}
        isComplete={isComplete}
        showFloatingReference={showFloatingReference}
        onToggleReference={() => setShowFloatingReference(!showFloatingReference)}
        onReset={resetGame}
      />

      <div className="relative flex w-full max-w-6xl flex-col items-center justify-center gap-6 lg:flex-row">
        {/* 浮动原图参考 */}
        {showFloatingReference && (
          <FloatingReference imageUrl={imageUrl} onClose={() => setShowFloatingReference(false)} />
        )}

        {/* 拼图区域 */}
        <div className="flex flex-col items-center">
          <PuzzleBoard
            size={size}
            puzzleSize={puzzleSize}
            slots={slots}
            pieces={pieces}
            wronglyPlacedPieces={wronglyPlacedPieces}
            selectedPlacedPiece={selectedPlacedPiece}
            draggedPiece={draggedPiece}
            imageUrl={imageUrl}
            getBackgroundSize={getBackgroundSizeMemo}
            getBackgroundPosition={getBackgroundPositionMemo}
            onSlotClick={handleSlotClick}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
          />

          {isComplete && (
            <CompletionMessage
              startTime={startTime}
              bestTime={stats.bestTime || 0}
              onReset={resetGame}
            />
          )}
        </div>

        {/* 拼图块选择区域 */}
        <div className="flex w-full flex-col items-center space-y-4 lg:w-auto">
          {/* 统计信息 */}
          <GameStats
            gamesCompleted={stats.gamesCompleted}
            bestTime={stats.bestTime}
            totalPiecesPlaced={stats.totalPiecesPlaced}
          />

          <PieceSelectionArea
            pieces={pieces}
            pieceGroups={layout.pieceGroups}
            colsPerRow={layout.colsPerRow}
            selectionPieceSize={layout.selectionPieceSize}
            imageUrl={imageUrl}
            size={size}
            imageDimensions={imageDimensions}
            draggedPiece={draggedPiece}
            showPieceNumbers={showPieceNumbers}
            showDebugInfo={showDebugInfo}
            piecePreviewVisible={piecePreviewVisible}
            piecePreviewPiece={piecePreviewPiece}
            piecePreviewPosition={piecePreviewPosition}
            currentTab={currentTab}
            tabsNeedScrolling={tabsNeedScrolling}
            availableHeight={availableHeight}
            actualAvailableForGrid={layout.actualAvailableForGrid}
            maxRows={layout.maxRows}
            piecesPerPage={layout.piecesPerPage}
            onTabChange={setCurrentTab}
            onToggleDebugInfo={() => setShowDebugInfo(!showDebugInfo)}
            onTogglePieceNumbers={() => setShowPieceNumbers(!showPieceNumbers)}
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
            onPieceClick={handlePieceClick}
            onPreviewStart={handlePiecePreviewStart}
            onPreviewEnd={handlePiecePreviewEnd}
            onTabsScrollingChange={setTabsNeedScrolling}
          />
        </div>
      </div>
    </div>
  )
}
